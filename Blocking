Yes — with AWR/ASH you can usually spot who was blocking around 00:15 without creating jobs. Below are short, ready-to-run queries you can run with your AWR access. They use the historical ASH view DBA_HIST_ACTIVE_SESS_HISTORY (the AWR copy of ASH) and are safe read-only.

I give:
	•	a tiny helper to find the AWR time window / snapshot ids,
	•	a main query that pulls ASH samples around the period and highlights blocking info,
	•	a follow up to resolve SQL text and the object name.

Run as a user with AWR/ASH access (typically a DBA user).

⸻

1) Find the time window / snapshot ids (optional, but useful)

This helps you get the exact timestamp range if you want snapshot-based filtering.

-- list AWR snapshots near the date you care about (change date)
SELECT snap_id, begin_interval_time, end_interval_time, instance_number
FROM dba_hist_snapshot
WHERE begin_interval_time >= TO_DATE('2025-12-05','YYYY-MM-DD') - 1
  AND begin_interval_time <= TO_DATE('2025-12-06','YYYY-MM-DD') + 1
ORDER BY begin_interval_time;

Note the snapshot(s) covering midnight. You can use snapshot time ranges or exact timestamps in the next queries.

⸻

2) Main ASH query — show blocking sessions and context around 00:15

Change the :start_ts and :end_ts to your window (for example 00:10..00:20 on the date). This returns session ids, blocking_session, instance, wait event, SQL_ID and a short SQL snippet (SQL_ID only here; get full text in step 3).

-- replace timestamps with the time window you want (use DB timezone / sample_time)
VAR start_ts VARCHAR2(30)
VAR end_ts   VARCHAR2(30)
EXEC :start_ts := '2025-12-06 00:10:00';
EXEC :end_ts   := '2025-12-06 00:20:00';

SET PAGESIZE 200
COL sample_time FORMAT A22
COL sql_id      FORMAT A13
COL event       FORMAT A40
COL program     FORMAT A30

SELECT
  sample_time,
  instance_number,
  session_id,
  session_serial#,
  session_type,
  username,
  program,
  module,
  sql_id,
  is_sqlid_current,
  event,
  wait_class,
  time_waited/1000000   AS seconds_waited,   -- time in seconds for in-progress waits
  blocking_session,
  blocking_session_serial#,
  blocking_inst_id,
  current_obj#,
  xid
FROM dba_hist_active_sess_history
WHERE sample_time BETWEEN TO_TIMESTAMP(:start_ts,'YYYY-MM-DD HH24:MI:SS')
                      AND TO_TIMESTAMP(:end_ts,'YYYY-MM-DD HH24:MI:SS')
  -- filter to rows likely relevant to locks/blocking (optional)
  AND (blocking_session IS NOT NULL
       OR LOWER(event) LIKE '%enq:%'
       OR LOWER(event) LIKE '%row lock%'
       OR wait_class = 'Concurrency')
ORDER BY sample_time, instance_number;

What to look for in that output
	•	BLOCKING_SESSION and BLOCKING_INST_ID identify the blocker. Use session_id, session_serial# together with instance_number (or blocking_inst_id) to uniquely identify the blocking session in RAC.
	•	EVENT will show something like enq: TX - row lock contention or enq: TM - contention etc.
	•	SECONDS_WAITED is how long that sample indicates the wait lasted (ASH samples are periodic; use as an indication).
	•	CURRENT_OBJ# is the object_id involved; you can map it to dba_objects to get schema and name.

⸻

3) Resolve SQL text and object name for suspicious rows

If the main query shows rows with a sql_id or a current_obj#, run these to get full SQL and object info.

Full SQL from AWR/ASH (use SQL_ID from step 2):

-- show SQL text from AWR SQL text repository
SELECT sql_id, piece, sql_text
FROM dba_hist_sqltext
WHERE sql_id = '&sql_id'
ORDER BY piece;

If DBA_HIST_SQLTEXT is not present in your environment, use DBA_HIST_SQLTEXT or ask your DBA to grant you access — otherwise you can report SQL_ID back here and I will tell you what to do next.

Object name from object id:

SELECT owner, object_name, object_type
FROM dba_objects
WHERE object_id = &current_obj_number;


⸻

4) If the blocker is on another instance (RAC)

ASH stores BLOCKING_INST_ID and INSTANCE_NUMBER. If BLOCKING_INST_ID is different from INSTANCE_NUMBER, the blocker ran on another RAC node — use the blocking pair (inst + session) for investigation:

-- get session detail from GV$SESSION like view for that instance and sid
SELECT inst_id, sid, serial#, username, program, machine, sql_id, status
FROM gv$session
WHERE inst_id = &blocking_inst_id
  AND sid = &blocking_session;

(You may not be able to query GV$ across instances in some access profiles; if so, rely on AWR rows which include block fields.)

⸻

5) Quick filter for common lock wait events (single shot)

To specifically hunt for enq: TX or TM waits around the time:

SELECT sample_time, instance_number, session_id, sql_id, event, wait_class,
       blocking_session, blocking_session_serial#, blocking_inst_id
FROM dba_hist_active_sess_history
WHERE sample_time BETWEEN TO_TIMESTAMP('2025-12-06 00:10:00','YYYY-MM-DD HH24:MI:SS')
                      AND TO_TIMESTAMP('2025-12-06 00:20:00','YYYY-MM-DD HH24:MI:SS')
  AND (event LIKE 'enq:%' OR LOWER(event) LIKE '%contention%' OR wait_class = 'Concurrency')
ORDER BY sample_time;


⸻

Interpretation tips
	•	If you see blocking_session populated and event like enq: TX - row lock contention, the blocker is an uncommitted DML transaction holding row locks. The blocking session info in the ASH row is the session to contact or to kill (if you accept rollback).
	•	If you see event like enq: TM - contention the conflict is DDL vs DML (table lock).
	•	PROGRAM often indicates the client (e.g., JDBC Thin Client), which helps point to app owner/connection pool.
	•	ASH is sampled (AWR writes one sample every 10 seconds to disk), so it may miss very short-lived blockers. But if the job runs daily and the blocking occurs repeatedly, AWR/ASH should show it.

⸻

Paste one or two rows from the ASH query (the columns sample_time, instance_number, session_id, session_serial#, sql_id, event, blocking_session, blocking_inst_id, current_obj#) and I will interpret exactly which session was the blocker and which object/SQL caused it and recommend immediate action.
